# Synchronizd 锁升级过程

最近在整理自己的技术体系，关于并发编程，入门级知识重量级锁Synchronized，接下来试着解释这块知识。

## 为什么说Synchronized是重量级锁

jdk1.6之前，还没有引入“偏向锁”和”轻量级锁“，synchronized是依赖monitorenter指令和monitorexit指令实现的，而这个jvm指令集是依赖操作系统内核来完成的，就会涉及到用户态与内核态的数据传递，是比较耗性能的，所以，我们前辈称之为重量级锁。



## 锁存放在哪里

对象的内存布局如下

![对象内存布局](https://newhcw.github.io/images/objectheader.png)

如图，对象头markword有锁的标记位，可以表示当前对象的锁的四种状态，无锁、偏向锁、轻量级锁、重量级锁。

参考[对象的内存布局](https://newhcw.github.io/20.06/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.html)



##  Jdk1.6是如何优化Synchronized的，让它“轻量级了”？

上面我们提到了，jdk1.6引入了锁的升级过程，锁分以下几种状态，

1. 无锁 （对象的初始状态）
2. 偏向锁
3. 轻量级锁
4. 重量级锁

那么锁的升级过程是什么样的？我们直接上图比较直观，

1.1 对象，最开始是无锁状态

1.2 线程A，进入同步方法块，先获取对象头是否有偏向锁标记，如果没有（即无锁状态），则将自己的线程id通过CAS操作塞进对象头中（升级为偏向锁）

1.3 如果对象头有偏向锁，判断是否等于自己的线程id，如果相等，则不需要申请锁，直接使用该锁。

1.4 如果不相等，则判断对象头的线程B是否存活，如果对象头存的线程B已经不是存活的，则将对象头重置为无锁或者将自己的线程id通过cas赋值进去。

```
偏向锁，自旋次数少，大部分的synchronized锁，都只是在无锁和偏向锁之间徘徊，消耗性能极低。
```



1.5 如果对象头存的线程B还是存活，则线程A自旋cas重试，当重试限定次数后，如果还是失败，则升级为轻量级锁。

```
轻量级锁，自旋次数多，cpu消耗比较高，好在它停留在jvm层面的自旋操作。
```



1.6 轻量级锁，是线程A将对象头的markword的锁空间复制到线程栈中，再将对象头通过cas指向线程栈的锁地址，如果指向成功，则申请锁成功，如果失败则自旋限定次数，如果还是失败，则竞争锁失败，升级为重量级锁。

```
重量级锁，使用monitorenter和monitorexit命令，依赖操作系统内存，涉及到用户态与内核态切换，比较耗费性能，不建议锁升级到此。
```

